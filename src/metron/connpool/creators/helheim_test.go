// This file was generated by github.com/nelsam/hel.  Do not
// edit this code by hand unless you *really* know what you're
// doing.  Expect any changes made manually to be overwritten
// the next time hel regenerates this file.

package creators_test

import "io"

type mockCreator struct {
	CreateCalled chan bool
	CreateOutput struct {
		Ret0 chan io.WriteCloser
	}
}

func newMockCreator() *mockCreator {
	m := &mockCreator{}
	m.CreateCalled = make(chan bool, 100)
	m.CreateOutput.Ret0 = make(chan io.WriteCloser, 100)
	return m
}
func (m *mockCreator) Create() io.WriteCloser {
	m.CreateCalled <- true
	return <-m.CreateOutput.Ret0
}

type mockTCPFinder struct {
	TCPServersCalled chan bool
	TCPServersOutput struct {
		Ret0 chan []string
	}
}

func newMockTCPFinder() *mockTCPFinder {
	m := &mockTCPFinder{}
	m.TCPServersCalled = make(chan bool, 100)
	m.TCPServersOutput.Ret0 = make(chan []string, 100)
	return m
}
func (m *mockTCPFinder) TCPServers() []string {
	m.TCPServersCalled <- true
	return <-m.TCPServersOutput.Ret0
}

type mockUDPFinder struct {
	UDPServersCalled chan bool
	UDPServersOutput struct {
		Ret0 chan []string
	}
}

func newMockUDPFinder() *mockUDPFinder {
	m := &mockUDPFinder{}
	m.UDPServersCalled = make(chan bool, 100)
	m.UDPServersOutput.Ret0 = make(chan []string, 100)
	return m
}
func (m *mockUDPFinder) UDPServers() []string {
	m.UDPServersCalled <- true
	return <-m.UDPServersOutput.Ret0
}

type mockWriteCloser struct {
	WriteCalled chan bool
	WriteInput  struct {
		P chan []byte
	}
	WriteOutput struct {
		N   chan int
		Err chan error
	}
	CloseCalled chan bool
	CloseOutput struct {
		Ret0 chan error
	}
}

func newMockWriteCloser() *mockWriteCloser {
	m := &mockWriteCloser{}
	m.WriteCalled = make(chan bool, 100)
	m.WriteInput.P = make(chan []byte, 100)
	m.WriteOutput.N = make(chan int, 100)
	m.WriteOutput.Err = make(chan error, 100)
	m.CloseCalled = make(chan bool, 100)
	m.CloseOutput.Ret0 = make(chan error, 100)
	return m
}
func (m *mockWriteCloser) Write(p []byte) (n int, err error) {
	m.WriteCalled <- true
	m.WriteInput.P <- p
	return <-m.WriteOutput.N, <-m.WriteOutput.Err
}
func (m *mockWriteCloser) Close() error {
	m.CloseCalled <- true
	return <-m.CloseOutput.Ret0
}
